# 						浏览器地址栏输入地址之后……

> 地址栏输入URL会发生什么，这个题目，可以说一年。
>
> ​																						——尼古拉斯·鲁

##### 对比本地浏览器缓存

​		浏览器根据域名，在本地缓存中寻找是否已经访问过，如果访问过，再走强缓存和协商缓存那一套，强缓存，对比过期时间，在合适情况下直接显示当前页面。

##### 根据规则解析url

​		以 http://news.baidu.com:80/internet为例，

​		协议部分:http

​		域名部分：news.baidu.com

​		端口：80

​		虚拟目录：/internet

​		根据规则，浏览器组装一个HTTP（Get）请求报文，将输入的域名进行解析，取得域名部分

​		return { http的请求报文 }

##### DNS解析过程

​				虽然上一步中，得到了news.baidu.com域名，但是浏览器是不知道主机在哪的，更无从建立连接和发送请求，因此建立连接的的第一步是通过dns寻址服务，找到域名的目标主机ip（这里不考虑集群cdn等）

​		DNS解析是逐级解析的，过程梳理如下

- 检查浏览器缓存

- 检查内存中dns缓存

- 查看本地host文件的修改

- 检查路由器中dns缓存

- 检查本地isp电信提供商的dns缓存

  如果上述缓存中都没有该域名的解析缓存，则逐步向上，直到根目录服务器。这个过程主要有迭代查询和递归查询:

  迭代查询：操作系统向dns服务器查询解析记录，如果没有，dns服务器向操作系统返回其他dns服务器。

  递归查询：操作系统向dns服务器查询解析记录，服务器如果没有，则自发查询其他dns服务器的dns记录，最后总会想操作系统返回dns解析记录。

  一般，两种查询过程交互存在。从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。

##### TCP三次握手

​		根据上个步骤中获得的IP地址，浏览器发送Http请求，由于http请求是应用层的协议，因此依赖处于传输层的TCP/IP协议。

​		![image-20200331213422976](C:\Users\17112598\AppData\Roaming\Typora\typora-user-images\image-20200331213422976.png)

TCP/IP的三次握手：

- 首先client发起请求，将自身SYN=1.发送seq=x到服务端，发送后，自身状态编程SYN-SEND状态

- 服务器Server接受到C发送过来的seq报文，将自身的SYN = 1 ACK =1 同时将将自身状态编程SYN-RECEIVED状态，，同时向C发送seq = 1，ack = x+1 的报文

- 客户端C接受到S发送过来的seq和ack报文，将自身ack= 1，同时自身状态置为ESTABLISHED ，同时向S发送seq = x+1，ack= y+1的报文

- 服务器S接收到客户端的seq和ack报文，将自身状态置为ESTABLISHED 

  SYN和ACK状态解释：

  1. **ACK**：确认标识，用于表示对数据包的成功接收。ACK置为1，表示已经收到seq=x的报文，且已经发还 ack = x+1的报文返回，这里的x是指对方刚才发过来的随机数seq的值

  2. **SYN**：同步标识，表示TCP连接已初始化。

  3. **FIN**：完成标识，用于拆除上一个SYN标识。

     三次握手的目的有两点：

     1. ​	确认c和s双方都有发送和接受消息的能力，避免无效的链接
     2.    避免已失效的请求连接的报文段传到服务端，服务端浪费网络连接数一直等待客户端

     经过三次握手，tcp链接已经建立，可以进行http请求了。

     

##### Http请求

​		后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。

​		这里主要是将请求分发到代理服务器，例如nginx服务器进行负载均衡等

##### Http响应

​		 经过上述一系列过程，服务器接受到客户端发送的的http请求，返回所需要的文档。

​		return {文档}

##### **页面渲染**

​		根据上个步骤中返回的文档，浏览器进行渲染。

[浅谈浏览器渲染、回流和重绘](https://juejin.im/post/5e8ec67ce51d4546fd4813d3)

> 构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制

1. ​	HTML和CSS经过各自解析，生成DOM树和CSSOM树

2. ​    合并成为渲染树

3.    根据渲染树进行布局

4.    最后调用GPU进行绘制，显示在屏幕上。

   ###### 根据浏览器渲染机制加快首屏速度

   - HTML和CSS的加载和解析都会阻塞渲染树的生成，因此优化大小，减少css层级，可以加快首屏速度
   - 浏览器解析到<script>标签时，会阻塞文档解析。因此我们通常把<script>标签放在底部，或者加上`defer、async`来进行异步下载

   ###### 页面重绘与回流

   ​		当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流

   ​		**重绘(repaint)**: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少

   ​		**回流(reflow):** 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。

   ​		会触发回流的操作:

   1. 添加或删除可见的DOM元素

   2. 元素的位置发生变化

   3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

   4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。

   5. 页面一开始渲染的时候（这肯定避免不了）

   6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的

      根据以上原则，可以基于重绘和回流做性能优化：

        css方面

      - 避免使用table布局
      - 将动画效果应用到position属性为absolute或fixed的元素上

      javascript

      - 避免频繁操作样式，可汇总后统一 一次修改

      - 尽量使用class进行样式修改

      - 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入

      - 极限优化时，修改样式可将其display: none后修改

      - 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住

        

##### TCP四次挥手

​		现在浏览器为了提高连接性能，一般都会保持连接，keep-alive模式，因此四次挥手一般发生在关闭浏览器标签页的时候。四次挥手是全双工的，连接双方都可以主动关闭，不过一般是由客户端发起关闭请求、

> 1. 客户端发送一个FIN置为1的包，ack = y， seq = x + 1，此时客户端的状态为 **FIN_WAIT_1**
> 2. 服务端收到包后，状态切换为**CLOSE_WAIT**发送一个ACK为1的包， ack = x + 2。客户端收到包之后状态切换为**FNI_WAIT_2**
> 3. 服务端处理完任务后，向客户端发送一个 FIN包，seq = y; 同时将自己的状态置为**LAST_ACK**
> 4. 客户端收到包后状态切换为**TIME_WAIT**，并向服务端发送ACK包，ack = y + 1，等待2MSL后关闭连接。





​		



​		

