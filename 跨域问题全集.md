# 					 跨域问题

[3000字说说跨域！面试官听完之后露出了满意的笑容]: https://juejin.im/post/5e74e690e51d4526d87c93df

​		跨域问题的由来，主要是因为网络通信同源策略的原因，网络通信同源策略：计算机通信过程中，非同源页面不能相互访问数据，所谓非同源是指，协议，域名，端口号，三者有一个不同。之所以有同源策略是考虑到安全方面，考虑到用户的隐私。最根本原因是因为通信协议的无状态话，服务器也不知道这个网络请求来自何处。谁说可以添加referer请求头标记网页来源，但是不能保证每个服务器后端都会参照字段进行识别。

​	跨域问题的解决方案主要有：

##### 	 CORS跨域请求

​		CORS（跨站资源共享）

​	`CORS`跨域分为两种请求，一种是**简单请求**，另外一种就是**复杂请求**。

​	简单请求：

- GET、POST、HEAD（注：什么是HEAD请求？HEAD请求和GET本质是一样的，但是HEAD请求不含数据，只有HTTP头部信息）
- HTTP头部信息不超过一下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）

​	非简单请求：

- 请求方式：PUT、DELETE
- 自定义头部字段
- 发送json格式数据
- 正式通信之前，浏览器会先发送OPTION请求，进行预检，这一次的请求称为“预检请求”
- 服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据

对于简单请求，可以通过设置服务器返回的时候的resHeader

```js

res.setHeader('Set-Cookie',"dit:diyValue")
res.setHeader('Access-Content-Allow-Origin','*')
// 请求代cookie过来还需要设置请求cookie的报文头
res.setHeader('Access-Content-Allow-Credentials','true')

```

对于非简单请求，处理需要处理正常get请求或者post请求返回的Header，还需要对option的预检请求做处理

```js
	if(method === 'OPTION' &&url === "/api/getMethod"  ) {
			res.writeHeade(200, {
				Access-Content-Allow-Origin','*',
        Access-Content-Allow-Header','diy-header',
        res.setHeader('Access-Content-Allow-Credentials','true')
        Access-Content-Allow-Methods','*'
      })
    res.end()
	}
```



#####  	JSONP跨域

#####      其他

​		document.domain

​		window.postMessage





​	  

